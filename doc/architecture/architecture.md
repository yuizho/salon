# Archtecture

## プロダクトの特性

- [RDRA(プロダクト要件整理)](/doc/product/rdra.md)
- 複数人が同じ部屋に入ってプランニングポーカーを実施する感じのアプリになるので、ユーザ側への push が必要
  - あるユーザが操作してから他のユーザの画面へ操作内容が反映されるまでは数秒くらいレイテンシがあっても問題ない (相手の操作が見えているわけでもないし、そこまでリアルタイム性は必要ない)
- ログインはしないで部屋を作ったり、プランニングポーカーに参加できる
- 個人アプリとして運用していくので、運用コストや費用はあまりかけられない

## 運用するうえで避けたいこと

- ユーザがいないにもかかわらずお金だけすごくかかること
- プロダクトの要件としてログイン不要で使えるものにしたいが、無限に部屋が作られ続けるみたいな自体は避けたい
- ユーザが急に増えた場合でもある程度スケールするようにしておきたい

## Backend の設計

![backend](./backend.svg)

- サーバレスなアーキテクチャを採用して、使われた分だけ費用がかかり、柔軟にスケールできるようにする
- DoS 攻撃とかの対策に AppSync の前に WAF をかます
- リアルタイムでユーザに情報を push していく感じのアプリになるので、書き込みの整合性の担保より、データストアの書き込み時のスケーラビリティが重要になる。そのため RDB は使わずに NoSQL を採用する。
- 責任範囲を明確にしてユーザへの push 処理もシンプルに実装したいので、EventSoursing + CQRS 採用する
  - そこまでレイテンシをシビアに管理しなくても大丈夫なので、お手軽さをとって DynamoDB Stream と Lambda で実装する
  - https://zenn.dev/j5ik2o/articles/368e0ab78f105f2a0fae
- ユーザへの push 処理の実装の容易さから、フロントエンドとの通信は GraphQL を採用する (ほんで、サーバレスでいきたいので AppSync で)

## Frontend の技術選定

Frontend 周りはわりと自分が使いやすいやつとか趣味とかで決めてる

- TypeScript
- Next.js
  - CSR 中心なので React でもいいんだけど、色々最適化が効くことや Router 周りで迷わなくても良くなったりするので Next.js を採用
- Tailwind CSS
  - これは趣味
- Amplify
  - GraphQL のクライアントとして使ってみてる
  - Backend 側で AppSync 使ってるから以上の理由はあんまりないので、これは後で見直すかもしれない
  - Amplify の機能で GraphQL のスキーマから TS のコードを自動生成してる
- Recoil
  - ポーカーやユーザの状態の管理を行う必要があるので状態管理ライブラリは必要だった
  - Atom と Selector の概念が今回作ろうとしてるものの相性が良さげだったので採用
    - User の状態を Atom で、Poker の状態を Selector でとか
